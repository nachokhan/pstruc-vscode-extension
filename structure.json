{
  "package.json": "{\n  \"name\": \"pstruc-ext\",\n  \"displayName\": \"Pstruc Extension\",\n  \"description\": \"The ultimate tool for generating a structured JSON representation of your project's file and directory hierarchy and content.\",\n  \"version\": \"1.0.4\",\n  \"publisher\": \"nachokhan\",\n  \"engines\": {\n    \"vscode\": \"^1.75.0\"\n  },\n  \"categories\": [\n    \"Other\"\n  ],\n  \"icon\": \"icon.png\",\n  \"activationEvents\": [\n    \"onCommand:extension.pstruc_extension\"\n  ],\n  \"main\": \"./out/extension.js\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/nachokhan/pstruc-vscode-extension\"\n  },\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"extension.pstruc_extension\",\n        \"title\": \"Pstruc: Generate JSON Structure\"\n      }\n    ],\n    \"menus\": {\n      \"explorer/context\": [\n        {\n          \"command\": \"extension.pstruc_extension\",\n          \"when\": \"resourceLangId != ''\",\n          \"group\": \"navigation\"\n        }\n      ]\n    },\n    \"configuration\": {\n      \"type\": \"object\",\n      \"title\": \"Pstruc Extension\",\n      \"properties\": {\n        \"pstruc_extension.ignorePatterns\": {\n          \"type\": \"array\",\n          \"default\": [],\n          \"description\": \"List of patterns to ignore when generating the structure.\"\n        },\n        \"pstruc_extension.hideBinaryContent\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"Hide the content of binary files.\"\n        },\n        \"pstruc_extension.outputFormat\": {\n          \"type\": \"string\",\n          \"enum\": [\n            \"json\",\n            \"pdf\",\n            \"yaml\"\n          ],\n          \"default\": \"json\",\n          \"description\": \"Output format for the structure file (JSON, PDF, or YAML).\"\n        }\n      }\n    }\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"yarn run compile\",\n    \"compile\": \"tsc -p ./\"\n  },\n  \"dependencies\": {\n    \"isbinaryfile\": \"^5.0.2\",\n    \"js-yaml\": \"^4.1.0\",\n    \"pdfkit\": \"^0.15.0\"\n  },\n  \"devDependencies\": {\n    \"@types/glob\": \"^8.1.0\",\n    \"@types/js-yaml\": \"^4.0.9\",\n    \"@types/mocha\": \"^10.0.7\",\n    \"@types/node\": \"^14.14.6\",\n    \"@types/pdfkit\": \"^0.13.4\",\n    \"@vscode/test-electron\": \"^2.4.1\",\n    \"typescript\": \"^4.0.3\",\n    \"vscode\": \"^1.1.37\"\n  }\n}\n",
  "README.md": "# Pstruc-Extension\n\nWelcome to **pstruc-ext**, the ultimate tool for generating a structured JSON representation of your project's file and directory hierarchy in Visual Studio Code. This extension simplifies the management of complex project structures by creating an easily navigable JSON file.\n\n![VPReview](./images/pstruc_example.gif)\n\n## Features\n\n- **Generate JSON Structure**: Quickly generate a JSON file (`structure.json`) that represents the file and directory hierarchy of your project.\n- **Customizable Ignore Patterns**: Use your own ignore patterns to exclude specific files or directories from the JSON structure.\n- **Efficient Processing**: Automatically replaces directories with their contained files and sorts items for optimal readability.\n- **Easy Integration**: Seamlessly integrates with your existing workflow in Visual Studio Code.\n\n## How to Use\n\n1. **Open Your Project**: Open the project you want to generate a structure for in Visual Studio Code.\n2. **Select Files/Folders**: Select the files and/or folders you want to include in the JSON structure.\n3. **Run the Command**: Open the command palette (`Ctrl+Shift+P` or `Cmd+Shift+P` on Mac) and run `Generate Structure`.\n4. **Copy the JSON File**: Copy the content of `structure.json` file (placed in the root of your workspace).\n5. **Paste it in some LLM**: Paste the `strcutre.json` content together with the prompt indicated inthe next section.\n6. **Ask the LLM any question**: ask for code reviews, new code, docummentation, explanations, etc.\n\n## Suggested PROMPT\n\nYou might change it for your personal interest, but here is a commonly useful prompt:\n\nRole: You are a coding assistant specializing in multiple programming languages. Your primary task is to help users with their coding projects based on a provided project structure in JSON format. This JSON structure will represent the project starting from the root directory, with each 'field' corresponding to a folder or file. Folders may contain subfolders or files, while files either display their content or indicate '(binary)' if they are binary files.\n\nInstructions:\n\n- Always begin by requesting the project structure in JSON format from the user.\n- After receiving the JSON structure, ask the user what specific coding assistance they need.\n- When suggesting code changes, if the modifications affect 15% or less of the original content, avoid returning the entire file. Instead, provide only the relevant changes.\n- If more than 15% of the code is modified, you may return the entire file, function, or relevant section that was altered.\n- Ensure all code names and comments you provide are in English.\n- Maintain a casual and friendly tone to make the interaction easygoing and approachable.\n\n\n## Requirements\n\n- Visual Studio Code version 1.50.0 or higher.\n\n## Extension Settings\n\nThis extension contributes the following settings:\n\n- `pstruc_extension.ignorePatterns`: Array of glob patterns to ignore specific files or directories.\n- `pstruc_extension.hideBinaryContent`: Boolean to hide binary file content by replacing it with \"(binary)\".\n\n## Known Issues\n\n- Currently, large projects with many nested directories might take longer to process.\n\n## Release Notes\n\n### 1.0.0\n\n- Initial release of `pstruc-ext`.\n\n### 1.0.1\n\n- Fixed minor bugs.\n\n### 1.0.2\n\n- Added \"Hide binary file's content\" option to replace binary file content with \"(binary)\" in the generated JSON structure. The option is enabled by default.\n- Fixed minor bugs.\n\n## Enjoy!\n\nWe hope you find `pstruc-ext` useful for managing your project structures. If you have any feedback or suggestions, please open an issue on our [GitHub repository](https://github.com/nachokhan/pstruc-vscode-extension).\n",
  "src": {
    "commands": {
      "generateStructure.ts": "import * as vscode from 'vscode';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as PDFDocument from 'pdfkit';\nimport * as YAML from 'js-yaml';\nimport { preprocessItems, processItem } from '../utils/structureUtils';\nimport { getSettings } from '../config/settings';\nimport { getWorkspaceFolder, getSelectedUris } from '../vscode/vscodeUtils';\n\nexport async function generateStructureCommand(uri: vscode.Uri, uris: vscode.Uri[]) {\n    const workspaceFolder = getWorkspaceFolder();\n    if (!workspaceFolder) {\n        vscode.window.showErrorMessage('No workspace open');\n        return;\n    }\n\n    const filePaths = getSelectedUris(uris);\n    const { ignorePatterns, hideBinaryContent, outputFormat } = getSettings();\n\n    let items = await preprocessItems(filePaths, workspaceFolder, ignorePatterns);\n\n    const structure: any = {};\n    for (const item of items) {\n        const relativePath = path.relative(workspaceFolder, item);\n        await processItem(item, relativePath.split(path.sep), structure, hideBinaryContent);\n    }\n\n    const structureFilePath = path.join(workspaceFolder, `structure.${outputFormat}`);\n    if (outputFormat === 'json') {\n        fs.writeFileSync(structureFilePath, JSON.stringify(structure, null, 2));\n    } else if (outputFormat === 'pdf') {\n        const doc = new PDFDocument();\n        doc.pipe(fs.createWriteStream(structureFilePath));\n        doc.text(JSON.stringify(structure, null, 2));\n        doc.end();\n    } else if (outputFormat === 'yaml') {\n        fs.writeFileSync(structureFilePath, YAML.dump(structure));\n    }\n\n    vscode.window.showInformationMessage(`Structure file created at: ${structureFilePath}`);\n}\n"
    },
    "config": {
      "settings.ts": "import * as vscode from 'vscode';\n\nexport function getSettings() {\n    const ignorePatterns = vscode.workspace.getConfiguration('pstruc_extension').get<string[]>('ignorePatterns', []);\n    const hideBinaryContent = vscode.workspace.getConfiguration('pstruc_extension').get<boolean>('hideBinaryContent', true);\n    const outputFormat = vscode.workspace.getConfiguration('pstruc_extension').get<string>('outputFormat', 'json');\n    \n    return { ignorePatterns, hideBinaryContent, outputFormat };\n}\n"
    },
    "extension.ts": "import * as vscode from 'vscode';\nimport { generateStructureCommand } from './commands/generateStructure';\n\nexport function activate(context: vscode.ExtensionContext) {\n    let disposable = vscode.commands.registerCommand('extension.pstruc_extension', generateStructureCommand);\n    context.subscriptions.push(disposable);\n}\n\nexport function deactivate() {}\n",
    "test": {
      "runTest.ts": "import { runTests } from '@vscode/test-electron';\nimport * as path from 'path';\n\nasync function main() {\n  try {\n    // The folder containing the Extension Manifest package.json\n    // Passed to `--extensionDevelopmentPath`\n    const extensionDevelopmentPath = path.resolve(__dirname, '../../');\n\n    // The path to test runner\n    // Passed to --extensionTestsPath\n    const extensionTestsPath = path.resolve(__dirname, './suite/index');\n\n    // Download VS Code, unzip it and run the integration test\n    await runTests({ extensionDevelopmentPath, extensionTestsPath });\n  } catch (err) {\n    console.error('Failed to run tests');\n    process.exit(1);\n  }\n}\n\nmain();\n",
      "suite": {
        "extension.test.ts": "import * as assert from 'assert';\n\nsuite('Extension Test Suite', () => {\n  test('Sample test', () => {\n    assert.strictEqual(-1, [1, 2, 3].indexOf(5));\n    assert.strictEqual(-1, [1, 2, 3].indexOf(0));\n  });\n});\n",
        "index.ts": "import * as path from 'path';\nimport * as Mocha from 'mocha';\nimport * as glob from 'glob';\n\nexport function run(testsRoot: string, cb: (error: any, failures?: number) => void): void {\n  // Create the mocha test\n  const mocha = new Mocha({\n    ui: 'tdd',\n    color: true\n  });\n\n  glob('**/**.test.js', { cwd: testsRoot }, (err, files) => {\n    if (err) {\n      return cb(err);\n    }\n\n    // Add files to the test suite\n    files.forEach(f => mocha.addFile(path.resolve(testsRoot, f)));\n\n    try {\n      // Run the mocha test\n      mocha.run(failures => {\n        cb(null, failures);\n      });\n    } catch (err) {\n      cb(err);\n    }\n  });\n}\n"
      }
    },
    "utils": {
      "fileUtils.ts": "import * as fs from 'fs';\nimport * as path from 'path';\n\nexport async function replaceDirectoryWithFiles(dirPath: string, items: string[]) {\n    const stats = fs.statSync(dirPath);\n    if (stats.isDirectory()) {\n        const entries = fs.readdirSync(dirPath);\n        for (const entry of entries) {\n            const entryPath = path.join(dirPath, entry);\n            await replaceDirectoryWithFiles(entryPath, items);\n        }\n    } else {\n        items.push(dirPath);\n    }\n}\n\nexport function sortItems(filePaths: string[], workspaceFolder: string): string[] {\n    return filePaths.sort((a, b) => {\n        const aPath = path.relative(workspaceFolder, a);\n        const bPath = path.relative(workspaceFolder, b);\n        const aIsDir = fs.statSync(a).isDirectory();\n        const bIsDir = fs.statSync(b).isDirectory();\n\n        if (aIsDir && !bIsDir) return 1;\n        if (!aIsDir && bIsDir) return -1;\n\n        return aPath.localeCompare(bPath);\n    });\n}\n",
      "structureUtils.ts": "import * as fs from 'fs';\nimport * as path from 'path';\nimport { isBinaryFile } from 'isbinaryfile';\nimport { replaceDirectoryWithFiles, sortItems } from './fileUtils';\n\nexport async function preprocessItems(filePaths: string[], workspaceFolder: string, ignorePatterns: string[]): Promise<string[]> {\n    let items: string[] = [];\n    for (const filePath of filePaths) {\n        await replaceDirectoryWithFiles(filePath, items);\n    }\n    items = sortItems(items, workspaceFolder);\n    items = filterIgnoredItems(items, ignorePatterns);\n    return items;\n}\n\nfunction filterIgnoredItems(filePaths: string[], patterns: string[]): string[] {\n    const regexPatterns = patterns.map(pattern => new RegExp(pattern.replace('.', '\\\\\\\\.').replace('*', '.*')));\n    return filePaths.filter(filePath => !regexPatterns.some(regex => regex.test(filePath)));\n}\n\nexport async function processItem(filePath: string, pathParts: string[], structure: any, hideBinaryContent: boolean) {\n    const stats = fs.statSync(filePath);\n    if (stats.isDirectory()) {\n        const entries = fs.readdirSync(filePath);\n        for (const entry of entries) {\n            const entryPath = path.join(filePath, entry);\n            const entryRelativePathParts = [...pathParts, entry];\n            await processItem(entryPath, entryRelativePathParts, structure, hideBinaryContent);\n        }\n    } else {\n        await addFileToStructure(structure, filePath, pathParts, hideBinaryContent);\n    }\n}\n\nasync function addFileToStructure(structure: any, filePath: string, pathParts: string[], hideBinaryContent: boolean) {\n    const name = pathParts.shift()!;\n    if (pathParts.length === 0) {\n        let content;\n        if (hideBinaryContent && await isBinaryFile(filePath)) {\n            content = '(binary)';\n        } else {\n            content = fs.readFileSync(filePath, 'utf-8');\n        }\n        structure[name] = content;\n    } else {\n        if (!structure[name]) {\n            structure[name] = {};\n        }\n        await addFileToStructure(structure[name], filePath, pathParts, hideBinaryContent);\n    }\n}\n"
    },
    "vscode": {
      "vscodeUtils.ts": "import * as vscode from 'vscode';\n\nexport function getWorkspaceFolder(): string | undefined {\n    return vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;\n}\n\nexport function getSelectedUris(uris: vscode.Uri[]): string[] {\n    return uris.map(uri => uri.fsPath);\n}\n"
    }
  }
}